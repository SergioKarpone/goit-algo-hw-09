# Порівняння алгоритмів видачі решти

У завданні було реалізовано два підходи до задачі розміну монет: *жадібний алгоритм* та *динамічне програмування* - порівняємо ефективність.

## 1. Жадібний алгоритм (find_coins_greedy)

### Принцип роботи
Алгоритм завжди вибирає монету найбільшого номіналу, яка не перевищує поточну залишкову суму.

### Часова складність
- **O(N)**, де *N* - кількість номіналів монет.
- фактично маємо **O(1)** оскільки набір монет фіксований (6 видів), складність - константа відносно суми, яку потрібно розміняти. Кількість операцій залежить лише від кількості типів монет, а не від величини суми.
- середній час: 0,000009 сек

### Переваги та недоліки
- *Переваги:* Дуже швидкий, простий у реалізації, потребує мінімум пам'яті.
- *Недоліки:* Не завжди гарантує знаходження мінімальної кількості монет для *довільних* наборів номіналів, проте для стандартних наборів монет (як у завданні або долар, гривня) він працює коректно.

## 2. Динамічне програмування (find_min_coins)

### Принцип роботи
Алгоритм будує рішення знизу вгору, обчислюючи мінімальну кількість монет для кожної суми від 0 до шуканої суми, гарантуючи знаходження глобального оптимуму.

### Часова складність
- фактично **O(N*A)**, де *A* - сума для розміну, а *N* - кількість номіналів монет.
- складність лінійно залежить від величини суми.
- середній час: 0,096101 сек

### Просторова складність
- **O(N)**, оскільки нам потрібно зберігати масив значень для кожної проміжної суми від 0 до A.

## Висновки порівняння

### Продуктивність при великих сумах
При тестуванні на великих сумах (наприклад, 10 000 або більше) різниця в часі виконання стає величезною:

1.  **Жадібний алгоритм** виконується миттєво, незалежно від того сума 100 чи 1 000 000 - просто виконується кілька арифметичних операцій ділення.
2.  **Динамічне програмування** значно сповільнюється зі зростанням суми. Якщо сума буде дуже великою, цей алгоритм може призвести до значних затримок або помилки нестачі пам'яті.

### Підсумок
Для даного конкретного набору монет [50, 25, 10, 5, 2, 1] *жадібний алгоритм є найбільш ефективним*.

- Він дає той самий оптимальний результат, що й динамічне програмування (через властивості цього набору монет).
- Він працює за константний час **O(1)** (відносно суми), тоді як динамічне програмування вимагає **O(N)** часу та пам'яті.

Метод динамічного програмування доцільно використовувати лише у випадках, коли набір монет не є канонічним і жадібний підхід не гарантує оптимального рішення.